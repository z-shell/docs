emulate -LR zsh
setopt extendedglob warncreateglobal noshortloops rcquotes

local user=$1 plugin=$2 id_as=$3 remote_url_path=${1:+$1/}$2 local_path tpe=$4 update=$5 version=$6

if .zi-get-object-path plugin "$id_as" && [[ -z $update ]] {
  +zi-message "{u-warn}ERROR{b-warn}:{error} A plugin named {pid}$id_as{error}" \
      "already exists, aborting."
  return 1
}
local_path=$REPLY

trap "rmdir ${(qqq)local_path}/._zi ${(qqq)local_path} 2>/dev/null" EXIT
trap "rmdir ${(qqq)local_path}/._zi ${(qqq)local_path} 2>/dev/null; return 1" INT TERM QUIT HUP

local -A sites
sites=(
  github    github.com
  gh        github.com
  bitbucket bitbucket.org
  bb        bitbucket.org
  gitlab    gitlab.com
  gl        gitlab.com
  notabug   notabug.org
  nb        notabug.org
  github-rel github.com/$remote_url_path/releases
  gh-r      github.com/$remote_url_path/releases
  cygwin    cygwin
)

ZI[annex-multi-flag:pull-active]=${${${(M)update:#-u}:+${ZI[annex-multi-flag:pull-active]}}:-2}

local -a arr

if [[ $user = _local ]]; then
  builtin print "Warning: no local plugin \`$plugin\'."
  builtin print "(should be located at: $local_path)"
  return 1
fi

command rm -f ${TMPDIR:-/tmp}/zi-execs.$$.lst ${TMPDIR:-/tmp}/zi.installed_comps.$$.lst \
      ${TMPDIR:-/tmp}/zi.skipped_comps.$$.lst ${TMPDIR:-/tmp}/zi.compiled.$$.lst

if [[ $tpe != tarball ]] {
  if [[ -z $update ]] {
    .zi-any-colorify-as-uspl2 "$user" "$plugin"
    local pid_hl='{pid}' id_msg_part=" (at label{ehi}:{rst} {id-as}$id_as{rst}{…})"
    (( $+ICE[pack] )) && local infix_m="({b}{ice}pack{apo}''{rst}) "
    +zi-message "{nl}Downloading $infix_m{pid}$user${user:+/}$plugin{…}${${${id_as:#$user/$plugin}}:+$id_msg_part}"
  }

  local site
  [[ -n ${ICE[from]} ]] && site=${sites[${ICE[from]}]}
  if [[ -z $site && ${ICE[from]} = *(gh-r|github-rel)* ]] {
    site=${ICE[from]/(gh-r|github-re)/${sites[gh-r]}}
  }
}

(
  if [[ $site = */releases ]] {
    local url=$site/${ICE[ver]}

    .zi-get-latest-gh-r-url-part "$user" "$plugin" "$url" || return $?

    command mkdir -p "$local_path"
    [[ -d "$local_path" ]] || return 1
    (
      () { setopt localoptions noautopushd; builtin cd -q "$local_path"; } || return 1
      integer count

      for REPLY ( $reply ) {
        count+=1
        url="https://github.com${REPLY}"
        if [[ -d $local_path/._zi ]] {
          { local old_version="$(<$local_path/._zi/is_release${count:#1})"; } 2>/dev/null
          old_version=${old_version/(#b)(\/[^\/]##)(#c4,4)\/([^\/]##)*/${match[2]}}
        }
        +zi-message "(Requesting \`${REPLY:t}'${version:+, version $version}{…}${old_version:+ Current version: $old_version.})"
        if { ! .zi-download-file-stdout "$url" 0 1 >| "${REPLY:t}" } {
          if { ! .zi-download-file-stdout "$url" 1 1 >| "${REPLY:t}" } {
            command rm -f "${REPLY:t}"
            +zi-message "Download of release for \`$remote_url_path' " "failed.{nl}Tried url: $url."
            return 1
          }
        }
        if .zi-download-file-stdout "$url.sig" 2>/dev/null >| "${REPLY:t}.sig"; then
          :
        else
          command rm -f "${REPLY:t}.sig"
        fi

        command mkdir -p ._zi
        [[ -d ._zi ]] || return 2
        builtin print -r -- $url >| ._zi/url || return 3
        builtin print -r -- ${REPLY} >| ._zi/is_release${count:#1} || return 4
        ziextract ${REPLY:t} ${${${#reply}:#1}:+--nobkp}
      }
      return $?
    ) || {
      return 1
    }
  } elif [[ $site = cygwin ]] {
    command mkdir -p "$local_path/._zi"
    [[ -d "$local_path" ]] || return 1
    (
      () { setopt localoptions noautopushd; builtin cd -q "$local_path"; } || return 1
      .zi-get-cygwin-package "$remote_url_path" || return 1
      builtin print -r -- $REPLY >| ._zi/is_release
      ziextract "$REPLY"
    ) || return $?
  } elif [[ $tpe = github ]] {
    case ${ICE[proto]} in
      (|https|git|http|ftp|ftps|rsync|ssh)
        :zi-git-clone() {
          command git clone --progress ${(s: :)ICE[cloneopts]---recursive} ${(s: :)ICE[depth]:+--depth ${ICE[depth]}} \
            "${ICE[proto]:-https}://${site:-${ICE[from]:-github.com}}/$remote_url_path" "$local_path" \
            --config transfer.fsckobjects=false --config receive.fsckobjects=false \
            --config fetch.fsckobjects=false --config pull.rebase=false
            integer retval=$?
            unfunction :zi-git-clone
            return $retval
        }
        :zi-git-clone |& { command ${ZI[BIN_DIR]}/lib/zsh/git-process-output.zsh || cat; }
        if (( pipestatus[1] == 141 )) {
          :zi-git-clone
          integer retval=$?
          if (( retval )) {
            builtin print -Pr -- "$ZI[col-error]Clone failed (code: $ZI[col-obj]$retval$ZI[col-error]).%f%b"
            return 1
          }
        } elif (( pipestatus[1] )) {
          builtin print -Pr -- "$ZI[col-error]Clone failed (code: $ZI[col-obj]$pipestatus[1]$ZI[col-error]).%f%b"
          return 1
        }
        ;;
      (*)
        builtin print -Pr "${ZI[col-error]}Unknown protocol:%f%b ${ICE[proto]}."
        return 1
    esac

    if [[ -n ${ICE[ver]} ]] {
      command git -C "$local_path" checkout "${ICE[ver]}"
    }
  }

  if [[ $update != -u ]] {
    .zi-store-ices "$local_path/._zi" ICE "" "" "" ""
    reply=(
      ${(on)ZI_EXTS2[(I)zi hook:\\\!atclone-pre <->]}
      ${(on)ZI_EXTS[(I)z-annex hook:\\\!atclone-<-> <->]}
      ${(on)ZI_EXTS2[(I)zi hook:\\\!atclone-post <->]}
    )
    for key in "${reply[@]}"; do
      arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
      "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_path" "${${key##(zi|z-annex) hook:}%% <->}" load
    done
    reply=(
      ${(on)ZI_EXTS2[(I)zi hook:atclone-pre <->]}
      ${(on)ZI_EXTS[(I)z-annex hook:atclone-<-> <->]}
      ${(on)ZI_EXTS2[(I)zi hook:atclone-post <->]}
    )
    for key in "${reply[@]}"; do
      arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
      "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_path" "${${key##(zi|z-annex) hook:}%% <->}"
    done
  }
  ((1))
) || return $?

typeset -ga INSTALLED_EXECS
{ INSTALLED_EXECS=( "${(@f)$(<${TMPDIR:-/tmp}/zi-execs.$$.lst)}" ) } 2>/dev/null
local -A OPTS
OPTS[opt_-q,--quiet]=1
[[ 0 = ${+ICE[nocompletions]} && ${ICE[as]} != null && ${+ICE[null]} -eq 0 ]] && \
  .zi-install-completions "$id_as" "" "0"

if [[ -e ${TMPDIR:-/tmp}/zi.skipped_comps.$$.lst || -e ${TMPDIR:-/tmp}/zi.installed_comps.$$.lst ]] {
  typeset -ga INSTALLED_COMPS SKIPPED_COMPS
  { INSTALLED_COMPS=( "${(@f)$(<${TMPDIR:-/tmp}/zi.installed_comps.$$.lst)}" ) } 2>/dev/null
  { SKIPPED_COMPS=( "${(@f)$(<${TMPDIR:-/tmp}/zi.skipped_comps.$$.lst)}" ) } 2>/dev/null
}

if [[ -e ${TMPDIR:-/tmp}/zi.compiled.$$.lst ]] {
  typeset -ga ADD_COMPILED
  { ADD_COMPILED=( "${(@f)$(<${TMPDIR:-/tmp}/zi.compiled.$$.lst)}" ) } 2>/dev/null
}
(( !OPTS[opt_-p,--parallel] )) && rehash

return 0
