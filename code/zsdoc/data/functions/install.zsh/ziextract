emulate -LR zsh
setopt extendedglob typesetsilent noshortloops

if (( $+commands[file] != 1 )) { +zi-message "{error}ziextract:{msg2} The {obj}file{msg2} command is required for recognizing the type of data to be processed.{rst}"; return 1; }
local -a opt_move opt_move2 opt_norm opt_auto opt_nobkp
zparseopts -D -E -move=opt_move -move2=opt_move2 -norm=opt_norm -auto=opt_auto -nobkp=opt_nobkp || \
{ +zi-message "{error}ziextract:{msg2} Incorrect options given to" "\`{pre}ziextract{msg2}' (available are: {meta}--auto{msg2}," \
"{meta}--move{msg2}, {meta}--move2{msg2}, {meta}--norm{msg2}," "{meta}--nobkp{msg2}).{rst}"; return 1; }

local file="$1" ext="$2"
integer move=${${${(M)${#opt_move}:#0}:+0}:-1} \
move2=${${${(M)${#opt_move2}:#0}:+0}:-1} \
norm=${${${(M)${#opt_norm}:#0}:+0}:-1} \
auto=${${${(M)${#opt_auto}:#0}:+0}:-1} \
nobkp=${${${(M)${#opt_nobkp}:#0}:+0}:-1}

if (( auto )) {
  local -a files
  integer ret_val
  files=( (#i)**/*.(zip|rar|7z|tgz|tbz2|tar.gz|tar.bz2|tar.7z|txz|tar.xz|gz|xz|tar|dmg|exe)~(*/*|.(_backup|git))/*(-.DN) )
  for file ( $files ) {
    ziextract "$file" $opt_move $opt_move2 $opt_norm $opt_nobkp ${${${#files}:#1}:+--nobkp}
    ret_val+=$?
  }
  if (( !${#files} )) {
    local -aU output infiles stage2_processed archives
    infiles=( **/*~(._zi*|._backup|.git)(|/*)~*/*/*(-.DN) )
    output=( ${(@f)"$(command file -- $infiles 2>&1)"} )
    archives=( ${(M)output[@]:#(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) *} )
    for file ( $archives ) {
      local fname=${(M)file#(${(~j:|:)infiles}): } desc=${file#(${(~j:|:)infiles}): } type
      fname=${fname%%??}
      [[ -z $fname || -n ${stage2_processed[(r)$fname]} ]] && continue
      type=${(L)desc/(#b)(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) */$match[2]}
      if [[ $type = (zip|rar|xz|7-zip|gzip|bzip2|tar|exe|pe32) ]] {
        (( !OPTS[opt_-q,--quiet] )) && \
          +zi-message "{pre}ziextract:{info2} Note:{rst}" "detected a {meta}$type{rst} archive in the file" "{file}$fname{rst}."
        ziextract "$fname" "$type" $opt_move $opt_move2 $opt_norm --norm ${${${#archives}:#1}:+--nobkp}
        integer iret_val=$?
        ret_val+=iret_val

        (( iret_val )) && continue
        local infname=$fname
        [[ -f $fname.out ]] && fname=$fname.out
        files=( *.tar(ND) )
        if [[ -f $fname || -f ${fname:r} ]] {
          local -aU output2 archives2
          output2=( ${(@f)"$(command file -- "$fname"(N) "${fname:r}"(N) $files[1](N) 2>&1)"} )
          archives2=( ${(M)output2[@]:#(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) *} )
          local file2
          for file2 ( $archives2 ) {
            fname=${file2%:*} desc=${file2##*:}
            local type2=${(L)desc/(#b)(#i)(* |(#s))(zip|rar|xz|7-zip|gzip|bzip2|tar|exe|PE32) */$match[2]}
            if [[ $type != $type2 && \
              $type2 = (zip|rar|xz|7-zip|gzip|bzip2|tar)
            ]] {
              [[ $fname != $infname && $norm -eq 0 ]] && command rm -f "$infname"
              (( !OPTS[opt_-q,--quiet] )) && \
                +zi-message "{pre}ziextract:{info2} Note:{rst}" "detected a {obj}${type2}{rst} archive in the" " file {file}${fname}{rst}."
              ziextract "$fname" "$type2" $opt_move $opt_move2 $opt_norm ${${${#archives}:#1}:+--nobkp}
              ret_val+=$?
              stage2_processed+=( $fname )
              if [[ $fname == *.out ]] {
                [[ -f $fname ]] && command mv -f "$fname" "${fname%.out}"
                stage2_processed+=( ${fname%.out} )
              }
            }
          }
        }
      }
    }
  }
  return $ret_val
}

if [[ -z $file ]] {
  +zi-message "{error}ziextract:{msg2} ERROR:{msg} argument" "needed (the file to extract) or the {meta}--auto{msg} option."
  return 1
}
if [[ ! -e $file ]] {
  +zi-message "{error}ziextract:{msg2} ERROR:{msg}" "the file \`{meta}${file}{msg}' doesn't exist.{rst}"
  return 1
}
if (( !nobkp )) {
  command mkdir -p ._backup
  command rm -rf ._backup/*(DN)
  command mv -f *~(._zi*|._backup|.git|.svn|.hg|$file)(DN) ._backup 2>/dev/null
}

.zi-extract-wrapper() {
  local file="$1" fun="$2" retval
  (( !OPTS[opt_-q,--quiet] )) && +zi-message "{pre}ziextract:{msg} Unpacking the files from: \`{obj}$file{msg}'{…}{rst}"
  $fun; retval=$?
  if (( retval == 0 )) {
    local -a files
    files=( *~(._zi*|._backup|.git|.svn|.hg|$file)(DN) )
    (( ${#files} && !norm )) && command rm -f "$file"
  }
  return $retval
}

→zi-check() { (( ${+commands[$1]} )) || +zi-message "{error}ziextract:{msg2} Error:{msg} No command {data}$1{msg}," \
  "it is required to unpack {file}$2{rst}."
}

case "${${ext:+.$ext}:-$file}" in
  ((
    →zi-extract() { →zi-check unzip "$file" || return 1; command unzip -o "$file"; }
    ;;
  ((
    →zi-extract() { →zi-check unrar "$file" || return 1; command unrar x "$file"; }
    ;;
  ((
    →zi-extract() { →zi-check bzip2 "$file" || return 1; command bzip2 -dc "$file" | command tar -xf -; }
    ;;
  ((
    →zi-extract() { →zi-check gzip "$file" || return 1; command gzip -dc "$file" | command tar -xf -; }
    ;;
  ((
    →zi-extract() { →zi-check xz "$file" || return 1; command xz -dc "$file" | command tar -xf -; }
    ;;
  ((
    →zi-extract() { →zi-check 7z "$file" || return 1; command 7z x -so "$file" | command tar -xf -; }
    ;;
  ((
    →zi-extract() { →zi-check tar "$file" || return 1; command tar -xf "$file"; }
    ;;
  ((
    if [[ $file != (#i)*.gz ]] {
      command mv $file $file.gz
      file=$file.gz
      integer zi_was_renamed=1
    }
    →zi-extract() {
      →zi-check gunzip "$file" || return 1
      .zi-get-mtime-into "$file" 'ZI[tmp]'
      command gunzip "$file" |& command egrep -v '.out$'
      integer ret=$pipestatus[1]
      command touch -t "$(strftime %Y%m%d%H%M.%S $ZI[tmp])" "$file"
      return ret
    }
    ;;
  ((
    if [[ $file != (#i)*.bz2 ]] {
      command mv $file $file.bz2
      file=$file.bz2
    }
    →zi-extract() { →zi-check bunzip2 "$file" || return 1
      .zi-get-mtime-into "$file" 'ZI[tmp]'
      command bunzip2 "$file" |& command egrep -v '.out$'
      integer ret=$pipestatus[1]
      command touch -t "$(strftime %Y%m%d%H%M.%S $ZI[tmp])" "$file"
      return ret
    }
    ;;
  ((
    if [[ $file != (#i)*.xz ]] {
      command mv $file $file.xz
      file=$file.xz
    }
    →zi-extract() { →zi-check xz "$file" || return 1
      .zi-get-mtime-into "$file" 'ZI[tmp]'
      command xz -d "$file"
      integer ret=$?
      command touch -t "$(strftime %Y%m%d%H%M.%S $ZI[tmp])" "$file"
      return ret
    }
    ;;
  ((
    →zi-extract() { →zi-check 7z "$file" || return 1; command 7z x "$file" >/dev/null;  }
    ;;
  ((
    →zi-extract() {
      local prog
      for prog ( hdiutil cp ) { →zi-check $prog "$file" || return 1; }

      integer retval
      local attached_vol="$( command hdiutil attach "$file" | \
          command tail -n1 | command cut -f 3 )"

      command cp -Rf ${attached_vol:-${TMPDIR:-/tmp}/acb321GEF}/*(D) .
      retval=$?
      command hdiutil detach $attached_vol

      if (( retval )) {
        +zi-message "{error}ziextract:{msg2} WARNING:{msg}" \
            "problem occurred when attempted to copy the files" \
            "from the mounted image: \`{obj}${file}{msg}'.{rst}"
      }
      return $retval
    }
    ;;
  ((
    →zi-extract() { →zi-check dpkg-deb "$file" || return 1; command dpkg-deb -R "$file" .; }
    ;;
  ((
    →zi-extract() { →zi-check cpio "$file" || return 1; $ZI[BIN_DIR]/lib/zsh/rpm2cpio.zsh "$file" | command cpio -imd --no-absolute-filenames; }
    ;;
  ((
    →zi-extract() {
      command chmod a+x -- ./$file
      ./$file /S /D="`cygpath -w $PWD`"
    }
    ;;
esac

if [[ $(typeset -f + →zi-extract) == "→zi-extract" ]] {
  .zi-extract-wrapper "$file" →zi-extract || {
    +zi-message -n "{error}ziextract:{msg2} WARNING:{msg}" \
      "extraction of the archive \`{file}${file}{msg}' had problems"
    local -a bfiles
    bfiles=( ._backup/*(DN) )
    if (( ${#bfiles} && !nobkp )) {
      +zi-message -n ", restoring the previous version of the plugin/snippet"
      command mv ._backup/*(DN) . 2>/dev/null
    }
    +zi-message ".{rst}"
    unfunction -- →zi-extract →zi-check 2>/dev/null
    return 1
  }
  unfunction -- →zi-extract →zi-check
} else {
  integer warning=1
}
unfunction -- .zi-extract-wrapper

local -a execs
execs=( **/*~(._zi(|/*)|.git(|/*)|.svn(|/*)|.hg(|/*)|._backup(|/*))(DN-.) )
if [[ ${#execs} -gt 0 && -n $execs ]] {
  execs=( ${(@f)"$( file ${execs[@]} )"} )
  execs=( "${(M)execs[@]:#[^:]##:*executable*}" )
  execs=( "${execs[@]/(#b)([^:]##):*/${match[1]}}" )
}

builtin print -rl -- ${execs[@]} >| ${TMPDIR:-/tmp}/zi-execs.$$.lst
if [[ ${#execs} -gt 0 ]] {
  command chmod a+x "${execs[@]}"
  if (( !OPTS[opt_-q,--quiet] )) {
    if (( ${#execs} == 1 )); then
        +zi-message "{pre}ziextract:{rst}" "Successfully extracted and assigned +x chmod to the file:" "\`{obj}${execs[1]}{rst}'."
    else
      local sep="$ZI[col-rst],$ZI[col-obj] "
      if (( ${#execs} > 7 )) {
        +zi-message "{pre}ziextract:{rst} Successfully" "extracted and marked executable the appropriate files" "({obj}${(pj:$sep:)${(@)execs[1,5]:t}},…{rst}) contained" \
          "in \`{file}$file{rst}'. All the extracted" "{obj}${#execs}{rst} executables are" "available in the {msg2}INSTALLED_EXECS{rst}" "array."
      } else {
        +zi-message "{pre}ziextract:{rst} Successfully" "extracted and marked executable the appropriate files" \
          "({obj}${(pj:$sep:)${execs[@]:t}}{rst}) contained" "in \`{file}$file{rst}'."
      }
    fi
  }
} elif (( warning )) {
  +zi-message "{pre}ziextract:" "{error}WARNING: {msg}didn't recognize the archive" "type of \`{obj}${file}{msg}'" \
    "${ext:+/ {obj2}${ext}{msg} }" "(no extraction has been done).%f%b"
}

if (( move | move2 )) {
  local -a files
  files=( *~(._zi|.git|._backup|.tmp231ABC)(DN/) )
  if (( ${#files} )) {
    command mkdir -p .tmp231ABC
    command mv -f *~(._zi|.git|._backup|.tmp231ABC)(D) .tmp231ABC
    if (( !move2 )) {
      command mv -f **/*~(*/*~*/*/*|*/*/*/*|^*/*|._zi(|/*)|.git(|/*)|._backup(|/*))(DN) .
    } else {
      command mv -f **/*~(*/*~*/*/*/*|*/*/*/*/*|^*/*|._zi(|/*)|.git(|/*)|._backup(|/*))(DN) .
    }
    command mv .tmp231ABC/$file . &>/dev/null
    command rm -rf .tmp231ABC
  }
  REPLY="${${execs[1]:h}:h}/${execs[1]:t}"
} else {
  REPLY="${execs[1]}"
}
return 0
