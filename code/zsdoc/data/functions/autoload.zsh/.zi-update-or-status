emulate -LR zsh
setopt extendedglob nullglob warncreateglobal typesetsilent noshortloops
local -a arr
ZI[first-plugin-mark]=${${ZI[first-plugin-mark]:#init}:-1}
ZI[-r/--reset-opt-hook-has-been-run]=0
.zi-set-m-func set
trap ".zi-set-m-func unset" EXIT
integer retval was_snippet
.zi-two-paths "$2${${2:#(%|/)*}:+${3:+/}}$3"
if [[ -d ${reply[-4]} || -d ${reply[-2]} ]]; then
  .zi-update-or-status-snippet "$1" "$2${${2:#(%|/)*}:+${3:+/}}$3"
  retval=$?
  was_snippet=1
fi
.zi-any-to-user-plugin "$2" "$3"
local user=${reply[-2]} plugin=${reply[-1]} st=$1 local_dir filename is_snippet key id_as="${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}"
local -A ice
if (( was_snippet )) {
  .zi-exists-physically "$user" "$plugin" || return $retval
  .zi-any-colorify-as-uspl2 "$2" "$3"
  (( !OPTS[opt_-q,--quiet] )) && +zi-message "{msg2}Updating also \`$REPLY{rst}{msg2}'" "plugin (already updated a snippet of the same name){â€¦}{rst}"
} else {
  .zi-exists-physically-message "$user" "$plugin" || return 1
}
if [[ $st = status ]]; then
  ( builtin cd -q ${ZI[PLUGINS_DIR]}/${user:+${user}---}${plugin//\//---}; command git status; )
  return $retval
fi
command rm -f ${TMPDIR:-${TMPDIR:-/tmp}}/zi-execs.$$.lst ${TMPDIR:-${TMPDIR:-/tmp}}/zi.installed_comps.$$.lst \
${TMPDIR:-${TMPDIR:-/tmp}}/zi.skipped_comps.$$.lst ${TMPDIR:-${TMPDIR:-/tmp}}/zi.compiled.$$.lst
ZI[annex-multi-flag:pull-active]=0
(( ${#ICE[@]} > 0 )) && { ZI_SICE[$user${${user:#(%|/)*}:+/}$plugin]=""; local nf="-nftid"; }
.zi-compute-ice "$user${${user:#(%|/)*}:+/}$plugin" "pack$nf" ice local_dir filename is_snippet || return 1
.zi-any-to-user-plugin ${ice[teleid]:-$id_as}
user=${reply[1]} plugin=${reply[2]}
local repo="${${${(M)id_as#%}:+${id_as#%}}:-${ZI[PLUGINS_DIR]}/${id_as//\//---}}"
local -a arr
reply=(
  ${(on)ZI_EXTS2[(I)zi hook:preinit-pre <->]}
  ${(on)ZI_EXTS[(I)z-annex hook:preinit-<-> <->]}
  ${(on)ZI_EXTS2[(I)zi hook:preinit-post <->]}
)
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
  "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" ${${key##(zi|z-annex) hook:}%% <->} update || \
    return $(( 10 - $? ))
done
if [[ -f $local_dir/.git/config ]]; then
  local -a config
  config=( ${(f)"$(<$local_dir/.git/config)"} )
  if [[ ${#${(M)config[@]:#\[remote[[:blank:]]*\]}} -eq 0 ]]; then
    (( !OPTS[opt_-q,--quiet] )) && {
      .zi-any-colorify-as-uspl2 "$id_as"
      [[ $id_as = _local/* ]] && builtin print -r -- "Skipping local plugin $REPLY" || \
        builtin print -r -- "$REPLY doesn't have a remote set, will not fetch"
    }
    return 1
  fi
fi
command rm -f $local_dir/.zi_lastupd
if (( 1 )); then
  if [[ -z ${ice[is_release]} && ${ice[from]} = (gh-r|github-rel|cygwin) ]] {
    ice[is_release]=true
  }
  integer count is_release=0
  for (( count = 1; count <= 5; ++ count )) {
    if (( ${+ice[is_release${count:#1}]} )) {
      is_release=1
    }
  }
  (( ${+functions[.zi-setup-plugin-dir]} )) || builtin source ${ZI[BIN_DIR]}"/lib/zsh/install.zsh"
  if [[ $ice[from] == (gh-r|github-rel) ]] {
    {
      ICE=( "${(kv)ice[@]}" )
      .zi-get-latest-gh-r-url-part "$user" "$plugin" || return $?
    } always {
      ICE=()
    }
  } else {
    REPLY=""
  }
  if (( is_release )) {
    count=0
    for REPLY ( $reply ) {
      count+=1
      local version=${REPLY/(#b)(\/[^\/]##)(#c4,4)\/([^\/]##)*/${match[2]}}
      if [[ ${ice[is_release${count:#1}]} = $REPLY ]] {
        (( ${+ice[run-atpull]} || OPTS[opt_-u,--urge] )) && ZI[annex-multi-flag:pull-active]=1 || ZI[annex-multi-flag:pull-active]=0
      } else {
        ZI[annex-multi-flag:pull-active]=2
        break
      }
    }
    if (( ZI[annex-multi-flag:pull-active] <= 1 && !OPTS[opt_-q,--quiet] )) {
      builtin print -- "\rBinary release already up to date (version: $version)"
    }
  }
  if (( 1 )) {
    if (( ZI[annex-multi-flag:pull-active] >= 1 )) {
      if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {
        .zi-any-colorify-as-uspl2 "$id_as"
        (( ZI[first-plugin-mark] )) && {
          ZI[first-plugin-mark]=0
        } || builtin print
        builtin print "\rUpdating $REPLY"
      }
      ICE=( "${(kv)ice[@]}" )
      reply=(
        ${(on)ZI_EXTS2[(I)zi hook:e-\\\!atpull-pre <->]}
        ${${(M)ICE[atpull]#\!}:+${(on)ZI_EXTS[(I)z-annex hook:\\\!atpull-<-> <->]}}
        ${(on)ZI_EXTS2[(I)zi hook:e-\\\!atpull-post <->]}
      )
      for key in "${reply[@]}"; do
        arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
        "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" "${${key##(zi|z-annex) hook:}%% <->}" update:bin
      done
      if (( ZI[annex-multi-flag:pull-active] >= 2 )) {
        if ! .zi-setup-plugin-dir "$user" "$plugin" "$id_as" release -u $version; then
          ZI[annex-multi-flag:pull-active]=0
        fi
        if (( OPTS[opt_-q,--quiet] != 1 )) {
          builtin print
        }
      }
      ICE=()
    }
  }
  if [[ -d $local_dir/.git ]] && ( builtin cd -q $local_dir ; git show-ref --verify --quiet refs/heads/main ); then
    local main_branch=main
  else
    local main_branch=master
  fi
  if (( ! is_release )) {
    ( builtin cd -q "$local_dir" || return 1
    integer had_output=0
    local IFS=$'\n'
    command git fetch --quiet && \
      command git log --color --date=short --pretty=format:'%Cgreen%cd %h %Creset%s%n' ..FETCH_HEAD | \
      while read line; do
        [[ -n ${line%%[[:space:]]##} ]] && {
          [[ $had_output -eq 0 ]] && {
            had_output=1
            if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {
              .zi-any-colorify-as-uspl2 "$id_as"
              (( ZI[first-plugin-mark] )) && {
              ZI[first-plugin-mark]=0
            } || builtin print
            builtin print "Updating $REPLY"
          }
        }
        builtin print $line
      }
      done | \
      command tee .zi_lastupd | \
      .zi-pager &
    integer pager_pid=$!
    { sleep 20 && kill -9 $pager_pid 2>/dev/null 1>&2; } &|
    { wait $pager_pid; } > /dev/null 2>&1
    local -a log
    { log=( ${(@f)"$(<$local_dir/.zi_lastupd)"} ); } 2>/dev/null
    command rm -f $local_dir/.zi_lastupd
    if [[ ${#log} -gt 0 ]] {
      ZI[annex-multi-flag:pull-active]=2
    } else {
      if (( ${+ice[run-atpull]} || OPTS[opt_-u,--urge] )) {
        ZI[annex-multi-flag:pull-active]=1
        if (( OPTS[opt_-q,--quiet] && !PUPDATE )) {
          .zi-any-colorify-as-uspl2 "$id_as"
          (( ZI[first-plugin-mark] )) && {
            ZI[first-plugin-mark]=0
          } || builtin print
          builtin print "\rUpdating $REPLY"
        }
      } else {
        ZI[annex-multi-flag:pull-active]=0
      }
    }
    if (( ZI[annex-multi-flag:pull-active] >= 1 )) {
      ICE=( "${(kv)ice[@]}" )
        reply=(
          ${(on)ZI_EXTS2[(I)zi hook:e-\\\!atpull-pre <->]}
          ${${(M)ICE[atpull]#\!}:+${(on)ZI_EXTS[(I)z-annex hook:\\\!atpull-<-> <->]}}
          ${(on)ZI_EXTS2[(I)zi hook:e-\\\!atpull-post <->]}
        )
      for key in "${reply[@]}"; do
        arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
        "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" "${${key##(zi|z-annex) hook:}%% <->}" update:git
      done
      ICE=()
      (( ZI[annex-multi-flag:pull-active] >= 2 )) && command git pull --no-stat ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} |& command egrep -v '(FETCH_HEAD|up.to.date\.|From.*://)'
    }
      return ${ZI[annex-multi-flag:pull-active]}
    )
    ZI[annex-multi-flag:pull-active]=$?
  }
  if [[ -d $local_dir/.git ]]; then
    (
      builtin cd -q "$local_dir"
      if (( OPTS[opt_-q,--quiet] )) {
        command git pull --recurse-submodules ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} &> /dev/null
      } else {
        command git pull --recurse-submodules ${=ice[pullopts]:---ff-only} origin ${ice[ver]:-$main_branch} |& command egrep -v '(FETCH_HEAD|up.to.date\.|From.*://)'
      }
    )
  fi
  if [[ -n ${(v)ice[(I)(mv|cp|atpull|ps-on-update|cargo)]} || $+ice[sbin]$+ice[make]$+ice[extract] -ne 0 ]] {
    if (( !OPTS[opt_-q,--quiet] && ZI[annex-multi-flag:pull-active] == 1 )) {
      +zi-message -n "{pre}[update]{msg3} Continuing with the update because "
      (( ${+ice[run-atpull]} )) && \
        +zi-message "{ice}run-atpull{apo}''{msg3} ice given.{rst}" || \
        +zi-message "{opt}-u{msg3}/{opt}--urge{msg3} given.{rst}"
    }
  }
  if (( ZI[annex-multi-flag:pull-active] >= 1  )) {
    ICE=( "${(kv)ice[@]}" )
    reply=(
      ${(on)ZI_EXTS2[(I)zi hook:no-e-\\\!atpull-pre <->]}
      ${${ICE[atpull]:#\!*}:+${(on)ZI_EXTS[(I)z-annex hook:\\\!atpull-<-> <->]}}
      ${(on)ZI_EXTS2[(I)zi hook:no-e-\\\!atpull-post <->]}
    )
    for key in "${reply[@]}"; do
      arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
      "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" "${${key##(zi|z-annex) hook:}%% <->}" update
    done
    reply=(
      ${(on)ZI_EXTS2[(I)zi hook:atpull-pre <->]}
      ${(on)ZI_EXTS[(I)z-annex hook:atpull-<-> <->]}
      ${(on)ZI_EXTS2[(I)zi hook:atpull-post <->]}
    )
    for key in "${reply[@]}"; do
      arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
      "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" "${${key##(zi|z-annex) hook:}%% <->}" update
    done
    ICE=()
  }
  .zi-store-ices "$local_dir/._zi" ice "" "" "" ""
fi
ICE=( "${(kv)ice[@]}" )
reply=(
  ${(on)ZI_EXTS2[(I)zi hook:%atpull-pre <->]}
  ${(on)ZI_EXTS[(I)z-annex hook:%atpull-<-> <->]}
  ${(on)ZI_EXTS2[(I)zi hook:%atpull-post <->]}
)
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
  "${arr[5]}" plugin "$user" "$plugin" "$id_as" "$local_dir" "${${key##(zi|z-annex) hook:}%% <->}" update:$ZI[annex-multi-flag:pull-active]
done
ICE=()
typeset -ga INSTALLED_EXECS
{ INSTALLED_EXECS=( "${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zi-execs.$$.lst)}" ) } 2>/dev/null
if [[ -e ${TMPDIR:-${TMPDIR:-/tmp}}/zi.skipped_comps.$$.lst || -e ${TMPDIR:-${TMPDIR:-/tmp}}/zi.installed_comps.$$.lst ]] {
  typeset -ga INSTALLED_COMPS SKIPPED_COMPS
  { INSTALLED_COMPS=( "${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zi.installed_comps.$$.lst)}" ) } 2>/dev/null
  { SKIPPED_COMPS=( "${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zi.skipped_comps.$$.lst)}" ) } 2>/dev/null
}
if [[ -e ${TMPDIR:-${TMPDIR:-/tmp}}/zi.compiled.$$.lst ]] {
  typeset -ga ADD_COMPILED
  { ADD_COMPILED=( "${(@f)$(<${TMPDIR:-${TMPDIR:-/tmp}}/zi.compiled.$$.lst)}" ) } 2>/dev/null
}
if (( PUPDATE && ZI[annex-multi-flag:pull-active] > 0 )) {
  builtin print ${ZI[annex-multi-flag:pull-active]} >| $PUFILE.ind
}
return $retval
