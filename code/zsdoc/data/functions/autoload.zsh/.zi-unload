.zi-any-to-user-plugin "$1" "$2"
local uspl2="${reply[-2]}${${reply[-2]:#(%|/)*}:+/}${reply[-1]}" user="${reply[-2]}" plugin="${reply[-1]}" quiet="${${3:+1}:-0}"
local k
.zi-any-colorify-as-uspl2 "$uspl2"
(( quiet )) || builtin print -r -- "${ZI[col-bar]}---${ZI[col-rst]} Unloading plugin: $REPLY ${ZI[col-bar]}---${ZI[col-rst]}"
local ___dir
[[ "$user" = "%" ]] && ___dir="$plugin" || ___dir="${ZI[PLUGINS_DIR]}/${user:+${user}---}${plugin//\//---}"
integer correct=0
[[ -o "KSH_ARRAYS" ]] && correct=1
if [[ "$uspl2" != "_dtrace/_dtrace" ]]; then
  .zi-exists-message "$1" "$2" || return 1
fi
.zi-any-colorify-as-uspl2 "$1" "$2"
local uspl2col="$REPLY"
typeset -g LASTREPORT
LASTREPORT=`.zi-show-report "$1" "$2"`

(( ${+functions[${plugin}_plugin_unload]} )) && ${plugin}_plugin_unload

local -a tmp
local -A sice
tmp=( "${(z@)ZI_SICE[$uspl2]}" )
(( ${#tmp} > 1 && ${#tmp} % 2 == 0 )) && sice=( "${(Q)tmp[@]}" ) || sice=()
if [[ -n ${sice[ps-on-unload]} ]]; then
  (( quiet )) || builtin print -r "Running plugin's provided unload code: ${ZI[col-info]}${sice[ps-on-unload][1,50]}${sice[ps-on-unload][51]:+â€¦}${ZI[col-rst]}"
  local ___oldcd="$PWD"
  () { setopt localoptions noautopushd; builtin cd -q "$___dir"; }
  eval "${sice[ps-on-unload]}"
  () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }
fi

typeset -a string_widget
string_widget=( "${(z)ZI[BINDKEYS__$uspl2]}" )
local sw
for sw in "${(Oa)string_widget[@]}"; do
  [[ -z "$sw" ]] && continue
  sw="${(Q)sw}"
  typeset -a sw_arr
  sw_arr=( "${(z)sw}" )
  local sw_arr1="${(Q)sw_arr[1-correct]}"
  local sw_arr2="${(Q)sw_arr[2-correct]}"
  local sw_arr3="${(Q)sw_arr[3-correct]}"
  local sw_arr4="${(Q)sw_arr[4-correct]}"
  local sw_arr5="${(Q)sw_arr[5-correct]}"
  local sw_arr6="${(Q)sw_arr[6-correct]}"
  if [[ "$sw_arr4" = "-M" && "$sw_arr6" != "-R" ]]; then
    if [[ -n "$sw_arr3" ]]; then
      () {
        emulate -LR zsh -o extendedglob
        (( quiet )) || builtin print -r "Restoring bindkey ${${(q)sw_arr1}//(#m)\\[\^\?\]\[\)\(\'\"\}\{\`]/${MATCH#\\}} $sw_arr3 ${ZI[col-info]}in map ${ZI[col-rst]}$sw_arr5"
      }
      bindkey -M "$sw_arr5" "$sw_arr1" "$sw_arr3"
    else
      (( quiet )) || builtin print -r "Deleting bindkey ${(q)sw_arr1} $sw_arr2 ${ZI[col-info]}in map ${ZI[col-rst]}$sw_arr5"
      bindkey -M "$sw_arr5" -r "$sw_arr1"
    fi
  elif [[ "$sw_arr4" = "-M" && "$sw_arr6" = "-R" ]]; then
    if [[ -n "$sw_arr3" ]]; then
      (( quiet )) || builtin print -r "Restoring ${ZI[col-info]}range${ZI[col-rst]} bindkey ${(q)sw_arr1} $sw_arr3 ${ZI[col-info]}in map ${ZI[col-rst]}$sw_arr5"
      bindkey -RM "$sw_arr5" "$sw_arr1" "$sw_arr3"
    else
      (( quiet )) || builtin print -r "Deleting ${ZI[col-info]}range${ZI[col-rst]} bindkey ${(q)sw_arr1} $sw_arr2 ${ZI[col-info]}in map ${ZI[col-rst]}$sw_arr5"
      bindkey -M "$sw_arr5" -Rr "$sw_arr1"
    fi
  elif [[ "$sw_arr4" != "-M" && "$sw_arr6" = "-R" ]]; then
    if [[ -n "$sw_arr3" ]]; then
      (( quiet )) || builtin print -r "Restoring ${ZI[col-info]}range${ZI[col-rst]} bindkey ${(q)sw_arr1} $sw_arr3"
      bindkey -R "$sw_arr1" "$sw_arr3"
    else
      (( quiet )) || builtin print -r "Deleting ${ZI[col-info]}range${ZI[col-rst]} bindkey ${(q)sw_arr1} $sw_arr2"
      bindkey -Rr "$sw_arr1"
    fi
  elif [[ "$sw_arr4" = "-A" ]]; then
    (( quiet )) || builtin print -r "Linking backup-\`main' keymap \`$sw_arr5' back to \`main'"
    bindkey -A "$sw_arr5" "main"
  elif [[ "$sw_arr4" = "-N" ]]; then
    (( quiet )) || builtin print -r "Deleting keymap \`$sw_arr5'"
    bindkey -D "$sw_arr5"
  else
    if [[ -n "$sw_arr3" ]]; then
      () {
        emulate -LR zsh -o extendedglob
        (( quiet )) || builtin print -r "Restoring bindkey ${${(q)sw_arr1}//(#m)\\[\^\?\]\[\)\(\'\"\}\{\`]/${MATCH#\\}} $sw_arr3"
      }
      bindkey "$sw_arr1" "$sw_arr3"
    else
      (( quiet )) || builtin print -r "Deleting bindkey ${(q)sw_arr1} $sw_arr2"
      bindkey -r "$sw_arr1"
    fi
  fi
done

typeset -a pattern_style
pattern_style=( "${(z)ZI[ZSTYLES__$uspl2]}" )
local ps
for ps in "${(Oa)pattern_style[@]}"; do
  [[ -z "$ps" ]] && continue
  ps="${(Q)ps}"
  typeset -a ps_arr
  ps_arr=( "${(z)ps}" )
  local ps_arr1="${(Q)ps_arr[1-correct]}"
  local ps_arr2="${(Q)ps_arr[2-correct]}"
  (( quiet )) || builtin print "Deleting zstyle $ps_arr1 $ps_arr2"
  zstyle -d "$ps_arr1" "$ps_arr2"
done
.zi-diff-options-compute "$uspl2"
integer empty=0
.zi-save-set-extendedglob
[[ "${ZI[OPTIONS__$uspl2]}" != *[$'! \t']* ]] && empty=1
.zi-restore-extendedglob
if (( empty != 1 )); then
  typeset -A opts
  opts=( "${(z)ZI[OPTIONS__$uspl2]}" )
  for k in "${(kon)opts[@]}"; do
    [[ "$k" = "physical" ]] && continue
    if [[ "${opts[$k]}" = "on" ]]; then
      (( quiet )) || builtin print "Setting option $k"
      builtin setopt "$k"
    else
      (( quiet )) || builtin print "Unsetting option $k"
      builtin unsetopt "$k"
    fi
  done
fi

typeset -a aname_avalue
aname_avalue=( "${(z)ZI[ALIASES__$uspl2]}" )
local nv
for nv in "${(Oa)aname_avalue[@]}"; do
  [[ -z "$nv" ]] && continue
  nv="${(Q)nv}"
  typeset -a nv_arr
  nv_arr=( "${(z)nv}" )
  local nv_arr1="${(Q)nv_arr[1-correct]}"
  local nv_arr2="${(Q)nv_arr[2-correct]}"
  local nv_arr3="${(Q)nv_arr[3-correct]}"
  if [[ "$nv_arr3" = "-s" ]]; then
    if [[ -n "$nv_arr2" ]]; then
      (( quiet )) || builtin print "Restoring ${ZI[col-info]}suffix${ZI[col-rst]} alias ${nv_arr1}=${nv_arr2}"
      alias "$nv_arr1" &> /dev/null && unalias -s -- "$nv_arr1"
      alias -s -- "${nv_arr1}=${nv_arr2}"
    else
      (( quiet )) || alias "$nv_arr1" &> /dev/null && {
        builtin print "Removing ${ZI[col-info]}suffix${ZI[col-rst]} alias ${nv_arr1}"
        unalias -s -- "$nv_arr1"
      }
    fi
  elif [[ "$nv_arr3" = "-g" ]]; then
    if [[ -n "$nv_arr2" ]]; then
      (( quiet )) || builtin print "Restoring ${ZI[col-info]}global${ZI[col-rst]} alias ${nv_arr1}=${nv_arr2}"
      alias "$nv_arr1" &> /dev/null && unalias -g -- "$nv_arr1"
      alias -g -- "${nv_arr1}=${nv_arr2}"
    else
      (( quiet )) || alias "$nv_arr1" &> /dev/null && {
        builtin print "Removing ${ZI[col-info]}global${ZI[col-rst]} alias ${nv_arr1}"
        unalias -- "${(q)nv_arr1}"
      }
    fi
  else
    if [[ -n "$nv_arr2" ]]; then
      (( quiet )) || builtin print "Restoring alias ${nv_arr1}=${nv_arr2}"
      alias "$nv_arr1" &> /dev/null && unalias -- "$nv_arr1"
      alias -- "${nv_arr1}=${nv_arr2}"
    else
      (( quiet )) || alias "$nv_arr1" &> /dev/null && {
        builtin print "Removing alias ${nv_arr1}"
        unalias -- "$nv_arr1"
      }
    fi
  fi
done

local -a keys
keys=( "${(@on)ZI[(I)TIME_<->_*]}" )
integer keys_size=${#keys}
() {
  setopt localoptions extendedglob noksharrays typesetsilent
  typeset -a restore_widgets skip_delete
  local wid
  restore_widgets=( "${(z)ZI[WIDGETS_SAVED__$uspl2]}" )
  for wid in "${(Oa)restore_widgets[@]}"; do
    [[ -z "$wid" ]] && continue
    wid="${(Q)wid}"
    typeset -a orig_saved
    orig_saved=( "${(z)wid}" )
    local tpe="${orig_saved[1]}"
    local orig_saved1="${(Q)orig_saved[2]}"
    local comp_wid="${(Q)orig_saved[3]}"
    local orig_saved2="${(Q)orig_saved[4]}"
    local orig_saved3="${(Q)orig_saved[5]}"
    local found_time_key="${keys[(r)TIME_<->_${uspl2//\//---}]}" to_process_plugin
    integer found_time_idx=0 idx=0
    to_process_plugin=""
    [[ "$found_time_key" = (#b)TIME_(<->)_* ]] && found_time_idx="${match[1]}"
    if (( found_time_idx )); then
      for (( idx = found_time_idx + 1; idx <= keys_size; ++ idx )); do
        found_time_key="${keys[(r)TIME_${idx}_*]}"
        local oth_uspl2=""
        [[ "$found_time_key" = (#b)TIME_${idx}_(*) ]] && oth_uspl2="${match[1]//---//}"
        local -a entry_splitted
        entry_splitted=( "${(z@)ZI[WIDGETS_SAVED__$oth_uspl2]}" )
        integer found_idx="${entry_splitted[(I)(-N|-C)\ $orig_saved1\\\ *]}"
        local -a entry_splitted2
        entry_splitted2=( "${(z@)ZI[BINDKEYS__$oth_uspl2]}" )
        integer found_idx2="${entry_splitted2[(I)*\ $orig_saved1\ *]}"
        if (( found_idx || found_idx2 ))
        then
          if [[ "$oth_uspl2" != "$uspl2" ]]; then
            to_process_plugin="$oth_uspl2"
            break
          fi
        fi
      done
      if [[ -n "$to_process_plugin" ]]; then
        if (( !found_idx && !found_idx2 )); then
          (( quiet )) || builtin print "Problem (1) during handling of widget \`$orig_saved1' (contents: $orig_saved2)"
          continue
        fi
        (( quiet )) || builtin print "Chaining widget \`$orig_saved1' to plugin $oth_uspl2"
        local -a oth_orig_saved
        if (( found_idx )) {
          oth_orig_saved=( "${(z)${(Q)entry_splitted[found_idx]}}" )
          local oth_fun="${oth_orig_saved[4]}"
          oth_orig_saved[5]="${(q)orig_saved3}"
          entry_splitted[found_idx]="${(q)${(j: :)oth_orig_saved}}"
          ZI[WIDGETS_SAVED__$oth_uspl2]="${(j: :)entry_splitted}"
        } else {
          oth_orig_saved=( "${(z)${(Q)entry_splitted2[found_idx2]}}" )
          local oth_fun="${widgets[${oth_orig_saved[3]}]#*:}"
        }
        integer idx="${functions[$orig_saved2][(i)(#b)([^[:space:]]#${orig_saved1}[^[:space:]]#)]}"
        if (( idx <= ${#functions[$orig_saved2]} ))
        then
          local prefix_X="${match[1]#\{}"
          [[ $prefix_X != \$* ]] && prefix_X="${prefix_X%\}}"
          idx="${functions[$oth_fun][(i)(#b)([^[:space:]]#${orig_saved1}[^[:space:]]#)]}"
          if (( idx <= ${#functions[$oth_fun]} )); then
            match[1]="${match[1]#\{}"
            [[ ${match[1]} != \$* ]] && match[1]="${match[1]%\}}"
            eval "local oth_prefix_uspl2_X=\"${match[1]}\""
            if [[ "${widgets[$prefix_X]}" = builtin ]]; then
              (( quiet )) || builtin print "Builtin-restoring widget \`$oth_prefix_uspl2_X' ($oth_uspl2)"
              zle -A ".${prefix_X#.}" "$oth_prefix_uspl2_X"
            elif [[ "${widgets[$prefix_X]}" = completion:* ]]; then
              (( quiet )) || builtin print "Chain*-restoring widget \`$oth_prefix_uspl2_X' ($oth_uspl2)"
              zle -C "$oth_prefix_uspl2_X" "${(@)${(@s.:.)${orig_saved3#user:}}[2,3]}"
            else
              (( quiet )) || builtin print "Chain-restoring widget \`$oth_prefix_uspl2_X' ($oth_uspl2)"
              zle -N "$oth_prefix_uspl2_X" "${widgets[$prefix_X]#user:}"
            fi
          fi
        fi
      else
        (( quiet )) || builtin print "Restoring Zle widget $orig_saved1"
        if [[ "$orig_saved3" = builtin ]]; then
          zle -A ".$orig_saved1" "$orig_saved1"
        elif [[ "$orig_saved3" = completion:* ]]; then
          zle -C "$orig_saved1" "${(@)${(@s.:.)${orig_saved3#user:}}[2,3]}"
        else
          zle -N "$orig_saved1" "${orig_saved3#user:}"
        fi
      fi
    else
      (( quiet )) || builtin print "Problem (2) during handling of widget \`$orig_saved1' (contents: $orig_saved2)"
    fi
  done
}
typeset -a delete_widgets
delete_widgets=( "${(z)ZI[WIDGETS_DELETE__$uspl2]}" )
local wid
for wid in "${(Oa)delete_widgets[@]}"; do
  [[ -z "$wid" ]] && continue
  wid="${(Q)wid}"
  if [[ -n "${skip_delete[(r)$wid]}" ]]; then
    builtin print "Would delete $wid"
    continue
  fi
  if [[ "${ZI_ZLE_HOOKS_LIST[$wid]}" = "1" ]]; then
    (( quiet )) || builtin print "Removing Zle hook \`$wid'"
  else
    (( quiet )) || builtin print "Removing Zle widget \`$wid'"
  fi
  zle -D "$wid"
done

.zi-diff-functions-compute "$uspl2"
typeset -a func
func=( "${(z)ZI[FUNCTIONS__$uspl2]}" )
local f
for f in "${(on)func[@]}"; do
  [[ -z "$f" ]] && continue
  f="${(Q)f}"
  (( quiet )) || builtin print "Deleting function $f"
  (( ${+functions[$f]} )) && unfunction -- "$f"
  (( ${+precmd_functions} )) && precmd_functions=( ${precmd_functions[@]:#$f} )
  (( ${+preexec_functions} )) && preexec_functions=( ${preexec_functions[@]:#$f} )
  (( ${+chpwd_functions} )) && chpwd_functions=( ${chpwd_functions[@]:#$f} )
  (( ${+periodic_functions} )) && periodic_functions=( ${periodic_functions[@]:#$f} )
  (( ${+zshaddhistory_functions} )) && zshaddhistory_functions=( ${zshaddhistory_functions[@]:#$f} )
  (( ${+zshexit_functions} )) && zshexit_functions=( ${zshexit_functions[@]:#$f} )
done

.zi-diff-env-compute "$uspl2"
typeset -a new elem p
elem=( "${(z)ZI[PATH__$uspl2]}" )
for p in "${path[@]}"; do
  if [[ -z "${elem[(r)${(q)p}]}" ]] {
    new+=( "$p" )
  } else {
    (( quiet )) || builtin print "Removing PATH element ${ZI[col-info]}$p${ZI[col-rst]}"
    [[ -d "$p" ]] || (( quiet )) || builtin print "${ZI[col-error]}Warning:${ZI[col-rst]} it didn't exist on disk"
  }
done
path=( "${new[@]}" )
elem=( "${(z)ZI[FPATH__$uspl2]}" )
new=( )
for p ( "${fpath[@]}" ) {
  if [[ -z "${elem[(r)${(q)p}]}" ]] {
    new+=( "$p" )
  } else {
    (( quiet )) || builtin print "Removing FPATH element ${ZI[col-info]}$p${ZI[col-rst]}"
    [[ -d "$p" ]] || (( quiet )) || builtin print "${ZI[col-error]}Warning:${ZI[col-rst]} it didn't exist on disk"
  }
}
fpath=( "${new[@]}" )

  .zi-diff-parameter-compute "$uspl2"
  empty=0
  .zi-save-set-extendedglob
  [[ "${ZI[PARAMETERS_POST__$uspl2]}" != *[$'! \t']* ]] && empty=1
  .zi-restore-extendedglob
  if (( empty != 1 )); then
    typeset -A elem_pre elem_post
    elem_pre=( "${(z)ZI[PARAMETERS_PRE__$uspl2]}" )
    elem_post=( "${(z)ZI[PARAMETERS_POST__$uspl2]}" )
    local wl found
    local -a whitelist
    whitelist=( "${(@Q)${(z@)ZI[ENV-WHITELIST]}}" )
    for k in "${(k)elem_post[@]}"; do
      k="${(Q)k}"
      local v1="${(Q)elem_pre[$k]}"
      local v2="${(Q)elem_post[$k]}"
      if [[ $v2 != '""' ]]; then
        [[ ${(tP)k} == *-readonly(|-*) ]] && continue
        case "$k" in
          (chpwd_functions|precmd_functions|preexec_functions|periodic_functions|zshaddhistory_functions|zshexit_functions|zsh_directory_name_functions)
            continue
          (path|PATH|fpath|FPATH)
            continue;
            ;;
        esac
        if [[ $v1 = '""' || ( $k = (RPROMPT|RPS1|RPS2|PROMPT|PS1|PS2|PS3|PS4) && $v1 != $v2 ) ]]; then
          found=0
          for wl in "${whitelist[@]}"; do
            if [[ "$k" = ${~wl} ]]; then
              found=1
              break
            fi
          done
          if (( !found )); then
            (( quiet )) || builtin print "Unsetting variable $k"
            unset -- "$k"
          else
            builtin print "Skipping unset of variable $k (whitelist)"
          fi
        fi
      fi
    done
  fi

if [[ "$uspl2" = "_dtrace/_dtrace" ]]; then
  .zi-clear-debug-report
  (( quiet )) || builtin print "dtrace report saved to \$LASTREPORT"
else
  (( quiet )) || builtin print "Unregistering plugin $uspl2col"
  .zi-unregister-plugin "$user" "$plugin" "${sice[teleid]}"
  zsh_loaded_plugins[${zsh_loaded_plugins[(i)$user${${user:#(%|/)*}:+/}$plugin]}]=()
  .zi-clear-report-for "$user" "$plugin"
  (( quiet )) || builtin print "Plugin's report saved to \$LASTREPORT"
fi
