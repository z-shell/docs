emulate -LR zsh
setopt extendedglob nullglob warncreateglobal typesetsilent noshortloops
local -F2 SECONDS=0
.zi-self-update -q
[[ $2 = restart ]] && +zi-message "{msg2}Restarting the update with the new codebase loaded.{rst}"$'\n'
local file
integer sum ela elb update_rc
.zi-get-mtime-into "${ZI[BIN_DIR]}/zi.zsh" ela; (( sum += ela ))
for file ( side install autoload ) {
  .zi-get-mtime-into "${ZI[BIN_DIR]}/lib/zsh/${file}.zsh" elb; (( sum += elb ))
}
if [[ $2 != restart ]] && (( ZI[mtime] + ZI[mtime-side] + ZI[mtime-install] + ZI[mtime-autoload] != sum )) {
  +zi-message "{msg2}Detected ❮ ZI ❯ update in another session -" "{pre}reloading{msg2}{…}{rst}"
  source ${ZI[BIN_DIR]}/zi.zsh
  source ${ZI[BIN_DIR]}/lib/zsh/side.zsh
  source ${ZI[BIN_DIR]}/lib/zsh/install.zsh
  source ${ZI[BIN_DIR]}/lib/zsh/autoload.zsh
  .zi-get-mtime-into "${ZI[BIN_DIR]}/zi.zsh" "ZI[mtime]"
  for file ( side install autoload ) {
    .zi-get-mtime-into "${ZI[BIN_DIR]}/lib/zsh/${file}.zsh" "ZI[mtime-${file}]"
  }
  +zi-message "{pname}Done.{rst}"$'\n'
  .zi-update-or-status-all "$1" restart
  return $?
}
if (( OPTS[opt_-p,--parallel] )) && [[ $1 = update ]] {
  (( !OPTS[opt_-q,--quiet] )) && \
    +zi-message '{info2}Parallel Update Starts Now{…}{rst}'
  .zi-update-all-parallel
  integer retval=$?
  .zi-compinit 1 1 &>/dev/null
  rehash
  if (( !OPTS[opt_-q,--quiet] )) {
    +zi-message "{msg2}The update took {obj}${SECONDS}{msg2} seconds{rst}"
  }
  return $retval
}
local st=$1 id_as repo snip pd user plugin
  integer PUPDATE=0
local -A ICE
if (( OPTS[opt_-s,--snippets] || !OPTS[opt_-l,--plugins] )) {
  local -a snipps
  snipps=( ${ZI[SNIPPETS_DIR]}/**/(._zi|._zinit|._zplugin)(ND) )
  [[ $st != status && ${OPTS[opt_-q,--quiet]} != 1 && -n $snipps ]] && +zi-message "{info}Note:{rst} updating also unloaded snippets"
  for snip ( ${ZI[SNIPPETS_DIR]}/**/(._zi|._zinit|._zplugin)/mode(D) ) {
    [[ ! -f ${snip:h}/url ]] && continue
    [[ -f ${snip:h}/id-as ]] && id_as="$(<${snip:h}/id-as)" || id_as=
    .zi-update-or-status-snippet "$st" "${id_as:-$(<${snip:h}/url)}"
    ICE=()
  }
  [[ -n $snipps ]] && builtin print
}
ICE=()
if (( OPTS[opt_-s,--snippets] && !OPTS[opt_-l,--plugins] )) {
  return
}
if [[ $st = status ]]; then
  (( !OPTS[opt_-q,--quiet] )) && +zi-message "{info}Note:{rst} status done also for unloaded plugins"
else
  (( !OPTS[opt_-q,--quiet] )) && +zi-message "{info}Note:{rst} updating also unloaded plugins"
fi
ZI[first-plugin-mark]=init
for repo in ${ZI[PLUGINS_DIR]}/*; do
  pd=${repo:t}
  [[ $pd = custom || $pd = _local---zi ]] && continue
  .zi-any-colorify-as-uspl2 "$pd"
  if [[ -f $repo/.git/config ]]; then
    local -a config
    config=( ${(f)"$(<$repo/.git/config)"} )
    if [[ ${#${(M)config[@]:#\[remote[[:blank:]]*\]}} -eq 0 ]]; then
      if (( !OPTS[opt_-q,--quiet] )) {
        [[ $pd = _local---* ]] && builtin print -- "\nSkipping local plugin $REPLY" || \
        builtin print "\n$REPLY doesn't have a remote set, will not fetch"
      }
      continue
    fi
  fi
  .zi-any-to-user-plugin "$pd"
  local user=${reply[-2]} plugin=${reply[-1]}
  if [[ ! -d $repo/.git && ! -f $repo/._zi/is_release ]]; then
    (( !OPTS[opt_-q,--quiet] )) && \
      builtin print "$REPLY: not a git repository"
    continue
  fi
  if [[ $st = status ]]; then
    builtin print "\nStatus for plugin $REPLY"
    ( builtin cd -q "$repo"; command git status )
  else
    (( !OPTS[opt_-q,--quiet] )) && builtin print "Updating $REPLY" || builtin print -n .
    .zi-update-or-status update "$user" "$plugin"
    update_rc=$?
    [[ $update_rc -ne 0 ]] && {
      +zi-message "{warn}Warning: {pid}${user}/${plugin} {warn}update returned {obj}$update_rc"
      retval=$?
    }
  fi
done
.zi-compinit 1 1 &>/dev/null
if (( !OPTS[opt_-q,--quiet] )) {
  +zi-message "{msg2}The update took {obj}${SECONDS}{msg2} seconds{rst}"
}
return "$retval"
