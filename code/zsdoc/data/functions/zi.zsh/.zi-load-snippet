typeset -F 3 SECONDS=0
local -a opts
zparseopts -E -D -a opts f -command || { +zi-message "{u-warn}Error{b-warn}:{rst} Incorrect options (accepted ones: {opt}-f{rst}, {opt}--command{rst})."; return 1; }
local url="$1"
[[ -n ${ICE[teleid]} ]] && url="${ICE[teleid]}"
builtin set --
integer correct retval exists
[[ -o ksharrays ]] && correct=1
[[ -n ${ICE[(i)(\!|)(sh|bash|ksh|csh)]}${ICE[opts]} ]] && {
  local -a precm
  precm=(
    emulate
    ${${(M)${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:+-R}
    ${${${ICE[(i)(\!|)(sh|bash|ksh|csh)]}#\!}:-zsh}
    ${${ICE[(i)(\!|)bash]}:+-${(s: :):-o noshglob -o braceexpand -o kshglob}}
    ${(s: :):-${${:-${(@s: :):--o}" "${(s: :)^ICE[opts]}}:#-o }}
    -c
  )
}
url="${${url#"${url%%[! $'\t']*}"}%/}"
ICE[teleid]="${ICE[teleid]:-$url}"
[[ ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ]] && ICE[pick]="${ICE[pick]:-/dev/null}"
local local_dir dirname filename save_url="$url"
eval "url=\"$url\""
local id_as="${ICE[id-as]:-$url}"
.zi-set-m-func set
if [[ -n ${ICE[param]} ]] {
  .zi-setup-params && local ${(Q)reply[@]}
}
.zi-pack-ice "$id_as" ""
[[ $url = *(${(~kj.|.)${(Mk)ZI_1MAP:#OMZ*}}|robbyrussell*oh-my-zsh|ohmyzsh/ohmyzsh)* ]] && local ZSH="${ZI[SNIPPETS_DIR]}"
.zi-get-object-path snippet "$id_as"
filename="${reply[-2]}" dirname="${reply[-2]}"
local_dir="${reply[-3]}" exists=${reply[-1]}
local -a arr
local key
reply=(
  ${(on)ZI_EXTS2[(I)zi hook:preinit-pre <->]}
  ${(on)ZI_EXTS[(I)z-annex hook:preinit-<-> <->]}
  ${(on)ZI_EXTS2[(I)zi hook:preinit-post <->]}
)
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]:-$ZI_EXTS2[$key]}[@]}" )
  "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" "${${key##(zi|z-annex) hook:}%% <->}" load || return $(( 10 - $? ))
done
if [[ -n ${opts[(r)-f]} || $exists -eq 0 ]] {
  (( ${+functions[.zi-download-snippet]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
  .zi-download-snippet "$save_url" "$url" "$id_as" "$local_dir" "$dirname" "$filename"
  retval=$?
}
(( ${+ICE[cloneonly]} || retval )) && return 0
ZI_SNIPPETS[$id_as]="$id_as <${${ICE[svn]+svn}:-single file}>"
ZI[CUR_USPL2]="$id_as" ZI_REPORTS[$id_as]=
reply=( ${(on)ZI_EXTS[(I)z-annex hook:\\\!atinit-<-> <->]} )
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]}[@]}" )
  "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atinit || return $(( 10 - $? ))
done
(( ${+ICE[atinit]} )) && { local ___oldcd="$PWD"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; } && eval "${ICE[atinit]}"; ((1)); } || eval "${ICE[atinit]}"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; }
reply=( ${(on)ZI_EXTS[(I)z-annex hook:atinit-<-> <->]} )
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]}[@]}" )
  "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" atinit || \
    return $(( 10 - $? ))
done
local -a list
local ZERO
if [[ -z ${opts[(r)--command]} && ( -z ${ICE[as]} || ${ICE[as]} = null || ${+ICE[null]} -eq 1 || ${+ICE[binary]} -eq 1 ) ]]; then
  if [[ ${ZI[TMP_SUBST]} = inactive ]]; then
    (( ${+functions[compdef]} )) && ZI[bkp-compdef]="${functions[compdef]}" || builtin unset "ZI[bkp-compdef]"
    functions[compdef]=':zi-tmp-subst-compdef "$@";'
    ZI[TMP_SUBST]=1
  else
    (( ++ ZI[TMP_SUBST] ))
  fi
  if [[ -d $local_dir/$dirname/functions ]] {
    [[ -z ${fpath[(r)$local_dir/$dirname/functions]} ]] && fpath+=( "$local_dir/$dirname/functions" )
    () {
      builtin setopt localoptions extendedglob
      autoload $local_dir/$dirname/functions/^([_.]*|prompt_*_setup|README*)(D-.N:t)
    }
  }
  if (( ${+ICE[svn]} == 0 )) {
    [[ ${+ICE[pick]} = 0 ]] && list=( "$local_dir/$dirname/$filename" )
    [[ -n ${ICE[pick]} ]] && list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )
  } else {
    if [[ -n ${ICE[pick]} ]]; then
      list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )
    elif (( ${+ICE[pick]} == 0 )); then
      .zi-find-other-matches "$local_dir/$dirname" "$filename"
      list=( ${reply[@]} )
    fi
  }
  if [[ -f ${list[1-correct]} ]] {
    ZERO="${list[1-correct]}"
    (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; }; (( retval += $? )); }
    (( 0 == retval )) && [[ $url = PZT::* || $url = https://github.com/sorin-ionescu/prezto/* ]] && zstyle ":prezto:module:${${id_as%/init.zsh}:t}" loaded 'yes'
  } else { [[ ${+ICE[silent]} -eq 1 || ${+ICE[pick]} -eq 1 && -z ${ICE[pick]} || ${ICE[pick]} = /dev/null ]] || { +zi-message "Snippet not loaded ({url}${id_as}{rst})"; retval=1; } }
  [[ -n ${ICE[src]} ]] && { ZERO="${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; }; (( retval += $? )); }; }
  [[ -n ${ICE[multisrc]} ]] && { local ___oldcd="$PWD"; () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; }; eval "reply=(${ICE[multisrc]})"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; local fname; for fname in "${reply[@]}"; do ZERO="${${(M)fname:#/*}:-$local_dir/$dirname/$fname}"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; }; (( retval += $? )); }; done; }
  reply=( ${(on)ZI_EXTS[(I)z-annex hook:\\\!atload-<-> <->]} )
  for key in "${reply[@]}"; do
    arr=( "${(Q)${(z@)ZI_EXTS[$key]}[@]}" )
    "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atload
  done
  if [[ -n ${ICE[wrap]} ]] {
    (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
    .zi-wrap-functions "$save_url" "" "$id_as"
  }
  [[ ${ICE[atload][1]} = "!" ]] && { .zi-add-report "$id_as" "Note: Starting to track the atload'!…' ice…"; ZERO="$local_dir/$dirname/-atload-"; local ___oldcd="$PWD"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; } && builtin eval "${ICE[atload]#\!}"; ((1)); } || eval "${ICE[atload]#\!}"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; }
  (( -- ZI[TMP_SUBST] == 0 )) && { ZI[TMP_SUBST]=inactive; builtin setopt noaliases; (( ${+ZI[bkp-compdef]} )) && functions[compdef]="${ZI[bkp-compdef]}" || unfunction compdef; (( ZI[ALIASES_OPT] )) && builtin setopt aliases; }
elif [[ -n ${opts[(r)--command]} || ${ICE[as]} = command ]]; then
  [[ ${+ICE[pick]} = 1 && -z ${ICE[pick]} ]] && ICE[pick]="${id_as:t}"
  if (( ${+ICE[svn]} )); then
    if [[ -n ${ICE[pick]} ]]; then
      list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )
      [[ -n ${list[1-correct]} ]] && local xpath="${list[1-correct]:h}" xfilepath="${list[1-correct]}"
    else
      local xpath="$local_dir/$dirname"
    fi
  else
    local xpath="$local_dir/$dirname" xfilepath="$local_dir/$dirname/$filename"
    [[ -n ${ICE[pick]} ]] && {
      list=( ${(M)~ICE[pick]##/*}(DN) $local_dir/$dirname/${~ICE[pick]}(DN) )
      [[ -n ${list[1-correct]} ]] && xpath="${list[1-correct]:h}" xfilepath="${list[1-correct]}"
    }
  fi
  [[ -n $xpath && -z ${path[(er)$xpath]} ]] && path=( "${xpath%/}" ${path[@]} )
  [[ -n $xfilepath && -f $xfilepath && ! -x "$xfilepath" ]] && command chmod a+x "$xfilepath" ${list[@]:#$xfilepath}
  [[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
    if [[ ${ZI[TMP_SUBST]} = inactive ]]; then
      (( ${+functions[compdef]} )) && ZI[bkp-compdef]="${functions[compdef]}" || builtin unset "ZI[bkp-compdef]"
      functions[compdef]=':zi-tmp-subst-compdef "$@";'
      ZI[TMP_SUBST]=1
    else
      (( ++ ZI[TMP_SUBST] ))
    fi
  }
  if [[ -n ${ICE[src]} ]]; then
    ZERO="${${(M)ICE[src]##/*}:-$local_dir/$dirname/${ICE[src]}}"
    (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; }; (( retval += $? )); }
  fi
  [[ -n ${ICE[multisrc]} ]] && { local ___oldcd="$PWD"; () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; }; eval "reply=(${ICE[multisrc]})"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; local fname; for fname in "${reply[@]}"; do ZERO="${${(M)fname:#/*}:-$local_dir/$dirname/$fname}"; (( ${+ICE[silent]} )) && { { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; } 2>/dev/null 1>&2; (( retval += $? )); ((1)); } || { ((1)); { [[ -n $precm ]] && { builtin ${precm[@]} 'source "$ZERO"'; ((1)); } || { ((1)); builtin source "$ZERO"; }; }; (( retval += $? )); }; done; }
  reply=( ${(on)ZI_EXTS[(I)z-annex hook:\\\!atload-<-> <->]} )
  for key in "${reply[@]}"; do
    arr=( "${(Q)${(z@)ZI_EXTS[$key]}[@]}" )
    "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" \!atload
  done
  if [[ -n ${ICE[wrap]} ]] {
    (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
    .zi-wrap-functions "$save_url" "" "$id_as"
  }
  [[ ${ICE[atload][1]} = "!" ]] && { .zi-add-report "$id_as" "Note: Starting to track the atload'!…' ice…"; ZERO="$local_dir/$dirname/-atload-"; local ___oldcd="$PWD"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; } && builtin eval "${ICE[atload]#\!}"; ((1)); } || eval "${ICE[atload]#\!}"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; }
  [[ -n ${ICE[src]} || -n ${ICE[multisrc]} || ${ICE[atload][1]} = "!" ]] && {
    (( -- ZI[TMP_SUBST] == 0 )) && { ZI[TMP_SUBST]=inactive; builtin setopt noaliases; (( ${+ZI[bkp-compdef]} )) && functions[compdef]="${ZI[bkp-compdef]}" || unfunction compdef; (( ZI[ALIASES_OPT] )) && builtin setopt aliases; }
  }
elif [[ ${ICE[as]} = completion ]]; then
  ((1))
fi
(( ${+ICE[atload]} )) && [[ ${ICE[atload][1]} != "!" ]] && { ZERO="$local_dir/$dirname/-atload-"; local ___oldcd="$PWD"; (( ${+ICE[nocd]} == 0 )) && { () { setopt localoptions noautopushd; builtin cd -q "$local_dir/$dirname"; } && builtin eval "${ICE[atload]}"; ((1)); } || eval "${ICE[atload]}"; () { setopt localoptions noautopushd; builtin cd -q "$___oldcd"; }; }
reply=( ${(on)ZI_EXTS[(I)z-annex hook:atload-<-> <->]} )
for key in "${reply[@]}"; do
  arr=( "${(Q)${(z@)ZI_EXTS[$key]}[@]}" )
  "${arr[5]}" snippet "$save_url" "$id_as" "$local_dir/$dirname" atload
done
(( ${+ICE[notify]} == 1 )) && { [[ $retval -eq 0 || -n ${(M)ICE[notify]#\!} ]] && { local msg; eval "msg=\"${ICE[notify]#\!}\""; +zi-deploy-message @msg "$msg" } || +zi-deploy-message @msg "notify: Plugin not loaded / loaded with problem, the return code: $retval"; }
(( ${+ICE[reset-prompt]} == 1 )) && +zi-deploy-message @rst
ZI[CUR_USPL2]=
ZI[TIME_INDEX]=$(( ${ZI[TIME_INDEX]:-0} + 1 ))
ZI[TIME_${ZI[TIME_INDEX]}_${id_as}]=$SECONDS
ZI[AT_TIME_${ZI[TIME_INDEX]}_${id_as}]=$EPOCHREALTIME
.zi-set-m-func unset
return retval
