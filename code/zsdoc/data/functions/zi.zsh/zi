local -A ICE ZI_ICE
ICE=( "${(kv)ZI_ICES[@]}" )
ZI_ICE=( "${(kv)ICE[@]}" )
ZI_ICES=()

integer ___retval ___retval2 ___correct
local -a match mbegin mend
local MATCH cmd ___q="\`" ___q2="'" IFS=$' \t\n\0'; integer MBEGIN MEND
match=( ${ZI_EXTS[(I)z-annex subcommand:$1]} )
if (( !${#match} )) {
  local -a reply; local REPLY
}

[[ -o ksharrays ]] && ___correct=1

local -A ___opt_map OPTS
___opt_map=(
  -q         opt_-q,--quiet:"update:[Turn off almost-all messages from the {cmd}update{rst} operation {b-lhi}FOR the objects{rst} which don't have any {b-lhi}new version{rst} available.] *:[Turn off any (or: almost-any) messages from the operation.]"
  --quiet    opt_-q,--quiet
  -v         opt_-v,--verbose:"Turn on more messages from the operation."
  --verbose  opt_-v,--verbose
  -r         opt_-r,--reset:"Reset the repository before updating (or remove the files for single-file snippets and gh-r plugins)."
  --reset    opt_-r,--reset
  -a         opt_-a,--all:"delete:[Delete {hi}all{rst} plugins and snippets.] update:[Update {b-lhi}all{rst} plugins and snippets.]"
  --all      opt_-a,--all
  -c         opt_-c,--clean:"Delete {b-lhi}only{rst} the {b-lhi}currently-not loaded{rst} plugins and snippets."
  --clean    opt_-c,--clean
  -y         opt_-y,--yes:"Automatically confirm any yes/no prompts."
  --yes      opt_-y,--yes
  -f         opt_-f,--force:"Force new download of the snippet file."
  --force    opt_-f,--force
  -p         opt_-p,--parallel:"Turn on concurrent, multi-thread update (of all objects)."
  --parallel opt_-p,--parallel
  -s         opt_-s,--snippets:"snippets:[Update only snippets (i.e.: skip updating plugins).] times:[Show times in seconds instead of milliseconds.]"
  --snippets opt_-s,--snippets
  -L         opt_-l,--plugins:"Update only plugins (i.e.: skip updating snippets)."
  --plugins  opt_-l,--plugins
  -h         opt_-h,--help:"Show this help message."
  --help     opt_-h,--help
  -u         opt_-u,--urge:"Cause all the hooks like{ehi}:{rst} {ice}atpull{apo}''{rst}, {ice}cp{apo}''{rst}, etc. to execute even when there aren't any new commits {b}/{rst} any new version of the {b}{meta}gh-r{rst} file {b}/{rst} etc.{…} available for download {ehi}{lr}{rst} simulate a non-empty update."
  --urge     opt_-u,--urge
  -n         opt_-n,--no-pager:"Disable the use of the pager."
  --no-pager opt_-n,--no-pager
  -m         opt_-m,--moments:"Show the {apo}*{b-lhi}moments{apo}*{rst} of object (i.e.: a plugin or snippet) loading time."
  --moments  opt_-m,--moments
  -b         opt_-b,--bindkeys:"Load in light mode, however do still track {cmd}bindkey{rst} calls (to allow remapping the keys bound)."
  --bindkeys opt_-b,--bindkeys
  -x         opt_-x,--command:"Load the snippet as a {cmd}command{rst}, i.e.: add it to {var}\$PATH{rst} and set {b-lhi}+x{rst} on it."
  --command  opt_-x,--command
  env-whitelist "-h|--help|-v|--verbose"
  update        "-L|--plugins|-s|--snippets|-p|--parallel|-a|--all|-q|--quiet|-r|--reset|-u|--urge|-n|--no-pager|-v|--verbose|-h|--help"
  delete        "-a|--all|-c|--clean|-y|--yes|-q|--quiet|-h|--help"
  unload        "-h|--help|-q|--quiet"
  cdclear       "-h|--help|-q|--quiet"
  cdreplay      "-h|--help|-q|--quiet"
  times         "-h|--help|-m|-s"
  light         "-h|--help|-b"
  snippet       "-h|--help|-f|--force|--command|-x"
)

cmd="$1"
if [[ $cmd == (times|unload|env-whitelist|update|snippet|load|light|cdreplay|cdclear|delete) ]]; then
  if (( $@[(I)-*] || OPTS[opt_-h,--help] )); then
    .zi-parse-opts "$cmd" "$@"
    if (( OPTS[opt_-h,--help] )); then
      +zi-prehelp-usage-message $cmd $___opt_map[$cmd] $@
      return 1;
    fi
  fi
fi

reply=( ${ZI_EXTS[(I)z-annex subcommand:*]} )

[[ -n $1 && $1 != (-h|--help|help|analytics|control|man|self-update|times|zstatus|load|light|unload|snippet|ls|ice|update|status|report|delete|loaded|list|cd|create|edit|glance|stress|changes|recently|clist|completions|cclear|cdisable|cenable|creinstall|cuninstall|csearch|compinit|dtrace|dstart|dstop|dunload|dreport|dclear|compile|uncompile|compiled|cdlist|cdreplay|cdclear|srv|recall|env-whitelist|bindkeys|module|add-fpath|run${reply:+|${(~j:|:)"${reply[@]#z-annex subcommand:}"}})nd:}"}}) || $1 = (load|light|snippet) ]] && {
  integer ___error
  if [[ $1 = (load|light|snippet) ]] {
    integer  ___is_snippet
    () {
      builtin setopt localoptions extendedglob
      : ${@[@]//(#b)([ $'\t']##|(#s))(-b|--command|-f|--force)([ $'\t']##|(#e))/${OPTS[${match[2]}]::=1}}
    } "$@"
    builtin set -- "${@[@]:#(-b|--command|-f|--force)}"
    [[ $1 = light && -z ${OPTS[(I)-b]} ]] && ICE[light-mode]=
    [[ $1 = snippet ]] && ICE[is-snippet]= || ___is_snippet=-1
    shift

    ZI_ICES=( "${(kv)ICE[@]}" )
    ICE=() ZI_ICE=()
    1="${1:+@}${1#@}${2:+/$2}"
    (( $# > 1 )) && { shift -p $(( $# - 1 )); }
    [[ -z $1 ]] && {
      +zi-message "Argument needed, try: {cmd}help."
      return 1
    }
  } else {
    .zi-ice "$@"
    ___retval2=$?
    local ___last_ice=${@[___retval2]}
    shift ___retval2
    if [[ $# -gt 0 && $1 != for ]] {
      +zi-message -n "{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:" "{apo}\`{cmd}$1{apo}\`{rst} "
      +zi-prehelp-usage-message rst
      return 1
    } elif (( $# == 0 )) {
      ___error=1
    } else {
      shift
    }
  }
  integer ___had_wait
  local ___id ___ehid ___etid ___key
  local -a ___arr
  ZI[annex-exposed-processed-IDs]=
  if (( $# )) {
    local -a ___ices
    ___ices=( "${(kv)ZI_ICES[@]}" )
    ZI_ICES=()
    while (( $# )) {
      .zi-ice "$@"
      ___retval2=$?
      local ___last_ice=${@[___retval2]}
      shift ___retval2
      if [[ -n $1 ]] {
        ICE=( "${___ices[@]}" "${(kv)ZI_ICES[@]}" )
        ZI_ICE=( "${(kv)ICE[@]}" ) ZI_ICES=()
        integer ___msgs=${+ICE[debug]}
        (( ___msgs )) && +zi-message "{pre}zi-main:{faint} Processing {pname}$1{faint}{…}{rst}"
        ZI[annex-exposed-processed-IDs]+="${___id:+ $___id}"
        ___id="${${1#@}%%(///|//|/)}"
        (( ___is_snippet == -1 )) && ___id="${___id#https://github.com/}"
        ___ehid="${ICE[id-as]:-$___id}"
        ___etid="${ICE[teleid]:-$___id}"
        if (( ${+ICE[pack]} )); then
          ___had_wait=${+ICE[wait]}
          .zi-load-ices "$___ehid"
          [[ $___had_wait -eq 0 ]] && unset 'ICE[wait]'
        fi
        [[ ${ICE[id-as]} = (auto|) && ${+ICE[id-as]} == 1 ]] && ICE[id-as]="${___etid:t}"
        integer  ___is_snippet=${${(M)___is_snippet:#-1}:-0}
        () {
          builtin setopt localoptions extendedglob
          if [[ $___is_snippet -ge 0 && ( -n ${ICE[is-snippet]+1} || $___etid = ((#i)(http(s|)|ftp(s|)):/|(${(~kj.|.)ZI_1MAP}))* ) ]] {
            ___is_snippet=1
          }
        } "$@"
        local ___type=${${${(M)___is_snippet:#1}:+snippet}:-plugin}
        reply=(
          ${(on)ZI_EXTS2[(I)zi hook:before-load-pre <->]}
          ${(on)ZI_EXTS[(I)z-annex hook:before-load-<-> <->]}
          ${(on)ZI_EXTS2[(I)zi hook:before-load-post <->]}
        )
        for ___key in "${reply[@]}"; do
          ___arr=( "${(Q)${(z@)ZI_EXTS[$___key]:-$ZI_EXTS2[$___key]}[@]}" )
          "${___arr[5]}" "$___type" "$___id" "${ICE[id_as]}" \
            "${(j: :)${(q)@[2,-1]}}" "${(j: :)${(qkv)___ices[@]}}" \
            "${${___key##(zi|z-annex) hook:}%% <->}" load
          ___retval2=$?
          if (( ___retval2 )) {
            ___retval+=$(( ___retval2 & 1 ? ___retval2 : 0 ))
            (( ___retval2 & 1 && $# )) && shift
            if (( ___retval2 & 2 )) {
              local -a ___args
              ___args=( "${(@Q)${(@z)ZI[annex-before-load:new-@]}}" )
              builtin set -- "${___args[@]}"
            }
            if (( ___retval2 & 4 )) {
              local -a ___new_ices
              ___new_ices=( "${(Q@)${(@z)ZI[annex-before-load:new-global-ices]}}" )
              (( 0 == ${#___new_ices} % 2 )) && \
                ___ices=( "${___new_ices[@]}" ) || \
                  { [[ ${ZI[MUTE_WARNINGS]} != (1|true|on|yes) ]] && \
                    +zi-message "{u-warn}Warning{b-warn}:{msg} Bad new-ices returned" \
                      "from the annex{ehi}:{rst} {annex}${___arr[3]}{msg}," \
                      "please file an issue report at:{url}" "https://github.com/z-shell/${___arr[3]}/issues/new{msg}.{rst}"
                    ___ices=(  ) ___retval+=7
                  }
            }
            continue 2
          }
        done
        integer ___action_load=0 ___turbo=0
        if [[ -n ${(M)${+ICE[wait]}:#1}${ICE[load]}${ICE[unload]}${ICE[service]}${ICE[subscribe]} ]] {
          ___turbo=1
        }

        if [[ -n ${ICE[trigger-load]} || ( ${+ICE[wait]} == 1 && ${ICE[wait]} = (\!|)(<->(a|b|c|)|) ) ]] && (( !ZI[OPTIMIZE_OUT_DISK_ACCESSES] )) {
          if (( ___is_snippet > 0 )) {
            .zi-get-object-path snippet $___ehid
          } else {
            .zi-get-object-path plugin $___ehid
          }
          (( $? )) && [[ ${zsh_eval_context[1]} = file ]] && { ___action_load=1; }
          local ___object_path="$REPLY"
        } elif (( ! ___turbo )) {
          ___action_load=1
          reply=( 1 )
        } else {
          reply=( 1 )
        }

        if [[ ${reply[-1]} -eq 1 && -n ${ICE[trigger-load]} ]] {
          () {
            builtin setopt localoptions extendedglob
            local ___mode
            (( ___is_snippet > 0 )) && ___mode=snippet || ___mode="${${${ICE[light-mode]+light}}:-load}"
            for MATCH ( ${(s.;.)ICE[trigger-load]} ) {
              eval "${MATCH#!}() {
                ${${(M)MATCH#!}:+unset -f ${MATCH#!}}
                local a b; local -a ices
                # The wait'' ice is filtered-out.
                for a b ( ${(qqkv@)${(kv@)ICE[(I)^(trigger-load|wait|light-mode)]}} ) {
                  ices+=( \"\$a\$b\" )
                }
                zi ice \${ices[@]}; zi $___mode ${(qqq)___id}
                ${${(M)MATCH#!}:+# Forward the call
                eval ${MATCH#!} \$@}
              }"
            }
          } "$@"
          ___retval+=$?
          (( $# )) && shift
          continue
        }

        if (( ${+ICE[if]} )) {
          eval "${ICE[if]}" || { (( $# )) && shift; continue; };
        }
        for REPLY ( ${(s.;.)ICE[has]} ) {
          (( ${+commands[$REPLY]} )) || { (( $# )) && shift; continue 2; }
        }

        integer ___had_cloneonly=0
        ICE[wait]="${${(M)${+ICE[wait]}:#1}:+${(M)ICE[wait]#!}${${ICE[wait]#!}:-0}}"
        if (( ___action_load || !ZI[HAVE_SCHEDULER] )) {
          if (( ___turbo && ZI[HAVE_SCHEDULER] )) {
            ___had_cloneonly=${+ICE[cloneonly]}
            ICE[cloneonly]=""
          }

          (( ___is_snippet )) && local ___opt="${(k)OPTS[*]}" || local ___opt="${${ICE[light-mode]+light}:-${OPTS[(I)-b]:+light-b}}"

          .zi-load-object ${${${(M)___is_snippet:#1}:+snippet}:-plugin} $___id $___opt
          integer ___last_retval=$?
          ___retval+=___last_retval

          if (( ___turbo && !___had_cloneonly && ZI[HAVE_SCHEDULER] )) {
            command rm -f $___object_path/._zi/cloneonly
            unset 'ICE[cloneonly]'
          }
        }
        if (( ___turbo && ZI[HAVE_SCHEDULER] && 0 == ___last_retval )) {
          ICE[wait]="${ICE[wait]:-${ICE[service]:+0}}"
          if (( ___is_snippet > 0 )); then
            ZI_SICE[$___ehid]=
            .zi-submit-turbo s${ICE[service]:+1} "" "$___id" "${(k)OPTS[*]}"
          else
            ZI_SICE[$___ehid]=
            .zi-submit-turbo p${ICE[service]:+1} "${${${ICE[light-mode]+light}}:-load}" "$___id" ""
          fi
          ___retval+=$?
        }
      } else {
        ___error=1
      }
      (( $# )) && shift
      ___is_snippet=0
    }
  } else {
    ___error=1
  }

  if (( ___error )) {
    () {
      emulate -LR zsh -o extendedglob
      +zi-message -n "{u-warn}Error{b-warn}:{rst} No plugin or snippet ID given"
      if [[ -n $___last_ice ]] {
        +zi-message -n " (the last recognized ice was: {ice}"\
        "${___last_ice/(#m)(${~ZI[ice-list]})/"{data}$MATCH"}{apo}''{rst}).{error}
        You can try to prepend {apo}${___q}{lhi}@{apo}'{error} to the ID if the last ice is in fact a plugin.{rst}
        {note}Note:{rst} The {apo}\`{ice}ice{apo}\`{rst} subcommand is now again required if not using the for-syntax"
      }
      +zi-message "."
    }
    return 2
  } elif (( ! $# )) {
    return ___retval
  }
}

case "$1" in
  (ice)
    shift
    .zi-ice "$@"
    ;;
  (cdreplay)
    .zi-compdef-replay "$2"; ___retval=$?
    ;;
  (cdclear)
    .zi-compdef-clear "$2"
    ;;
  (add-fpath)
    .zi-add-fpath "${@[2-correct,-1]}"
    ;;
  (run)
    .zi-run "${@[2-correct,-1]}"
    ;;
  (dstart|dtrace)
    (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
    .zi-debug-start
    ;;
  (dstop)
    (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
    .zi-debug-stop
    ;;
  (man)
    man "${ZI[BIN_DIR]}/docs/man/zi.1"
    ;;
  (env-whitelist)
    shift
    .zi-parse-opts env-whitelist "$@"
    builtin set -- "${reply[@]}"

    if (( $# == 0 )) {
      ZI[ENV-WHITELIST]=
      (( OPTS[opt_-v,--verbose] )) && +zi-message "{msg2}Cleared the parameter whitelist.{rst}"
    } else {
      ZI[ENV-WHITELIST]+="${(j: :)${(q-kv)@}} "
      local ___sep="$ZI[col-msg2], $ZI[col-data2]"
      (( OPTS[opt_-v,--verbose] )) && +zi-message "{msg2}Extended the parameter whitelist with: {data2}${(pj:$___sep:)@}{msg2}.{rst}"
    }
    ;;
  (*)
    reply=( ${ZI_EXTS[z-annex subcommand:${(q)1}]} )
    (( ${#reply} )) && {
      reply=( "${(Q)${(z@)reply[1]}[@]}" )
      (( ${+functions[${reply[5]}]} )) && { "${reply[5]}" "$@"; return $?; } || \
        { +zi-message "({error}Couldn't find the subcommand-handler \`{obj}${reply[5]}{error}' of the z-annex \`{file}${reply[3]}{error}')"; return 1; }
    }
    (( ${+functions[.zi-confirm]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/autoload.zsh" || return 1
    case "$1" in
      (zstatus)
        .zi-show-zstatus
        ;;
      (times)
        .zi-show-times "${@[2-correct,-1]}"
        ;;
      (self-update)
        .zi-self-update
        ;;
      (unload)
        (( ${+functions[.zi-unload]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/autoload.zsh" || return 1
        if [[ -z $2 && -z $3 ]]; then
          builtin print "Argument needed, try: help"; ___retval=1
        else
          [[ $2 = -q ]] && { 5=-q; shift; }
          .zi-unload "${2%%(///|//|/)}" "${${3:#-q}%%(///|//|/)}" "${${(M)4:#-q}:-${(M)3:#-q}}"; ___retval=$?
        fi
        ;;
      (bindkeys)
        .zi-list-bindkeys
        ;;
      (update)
        if (( ${+ICE[if]} )) {
          eval "${ICE[if]}" || return 1;
        }
        for REPLY ( ${(s.;.)ICE[has]} ) {
          (( ${+commands[$REPLY]} )) || return 1
        }
        shift
        .zi-parse-opts update "$@"
        builtin set -- "${reply[@]}"
        if [[ ${OPTS[opt_-a,--all]} -eq 1 || ${OPTS[opt_-p,--parallel]} -eq 1 || ${OPTS[opt_-s,--snippets]} -eq 1 || ${OPTS[opt_-l,--plugins]} -eq 1 || -z $1$2${ICE[teleid]}${ICE[id-as]} ]]; then
          [[ -z $1$2 && $(( OPTS[opt_-a,--all] + OPTS[opt_-p,--parallel] + OPTS[opt_-s,--snippets] + OPTS[opt_-l,--plugins] )) -eq 0 ]] && { builtin print -r -- "Assuming --all is passed"; sleep 3; }
          (( OPTS[opt_-p,--parallel] )) && OPTS[value]=${1:-15}
          .zi-update-or-status-all update; ___retval=$?
        else
          local ___key ___id="${1%%(///|//|/)}${2:+/}${2%%(///|//|/)}"
          [[ -z ${___id//[[:space:]]/} ]] && ___id="${ICE[id-as]:-$ICE[teleid]}"
          .zi-update-or-status update "$___id" ""; ___retval=$?
        fi
        ;;
      (status)
        if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then
          [[ -z $2 ]] && { builtin print -r -- "Assuming --all is passed"; sleep 3; }
          .zi-update-or-status-all status; ___retval=$?
        else
          .zi-update-or-status status "${2%%(///|//|/)}" "${3%%(///|//|/)}"; ___retval=$?
        fi
        ;;
      (report)
        if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then
          [[ -z $2 ]] && { builtin print -r -- "Assuming --all is passed"; sleep 4; }
        .zi-show-all-reports
        else
          .zi-show-report "${2%%(///|//|/)}" "${3%%(///|//|/)}"; ___retval=$?
        fi
        ;;
      (loaded|list)
        .zi-show-registered-plugins "$2"
        ;;
      (clist|completions)
        .zi-show-completions "$2"
        ;;
      (cclear)
        .zi-clear-completions
        ;;
      (cdisable)
        if [[ -z $2 ]]; then
          builtin print "Argument needed, try: help"; ___retval=1
        else
          local ___f="_${2#_}"
          if .zi-cdisable "$___f"; then
            (( ${+functions[.zi-forget-completion]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
            .zi-forget-completion "$___f"
            +zi-message "Initializing completion system ({func}compinit{rst}){…}"
            builtin autoload -Uz compinit
            compinit -d ${ZI[ZCOMPDUMP_PATH]:-${XDG_DATA_HOME:-$ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZI[COMPINIT_OPTS]}}"
          else
            ___retval=1
          fi
        fi
        ;;
      (cenable)
        if [[ -z $2 ]]; then
          builtin print "Argument needed, try: help"; ___retval=1
        else
          local ___f="_${2#_}"
          if .zi-cenable "$___f"; then
            (( ${+functions[.zi-forget-completion]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
            .zi-forget-completion "$___f"
            +zi-message "Initializing completion system ({func}compinit{rst}){…}"
            builtin autoload -Uz compinit
            compinit -d ${ZI[ZCOMPDUMP_PATH]:-${XDG_DATA_HOME:-$ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZI[COMPINIT_OPTS]}}"
          else
            ___retval=1
          fi
        fi
        ;;
      (creinstall)
        (( ${+functions[.zi-install-completions]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
        [[ $2 = -[qQ] ]] && { 5=$2; shift; }
        .zi-install-completions "${2%%(///|//|/)}" "${3%%(///|//|/)}" 1 "${(M)4:#-[qQ]}"; ___retval=$?
        [[ -z ${(M)4:#-[qQ]} ]] && +zi-message "Initializing completion ({func}compinit{rst}){…}"
        builtin autoload -Uz compinit
        compinit -d ${ZI[ZCOMPDUMP_PATH]:-${XDG_DATA_HOME:-$ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZI[COMPINIT_OPTS]}}"
        ;;
      (cuninstall)
        if [[ -z $2 && -z $3 ]]; then
          builtin print "Argument needed, try: help"; ___retval=1
        else
          (( ${+functions[.zi-forget-completion]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
          .zi-uninstall-completions "${2%%(///|//|/)}" "${3%%(///|//|/)}"; ___retval=$?
          +zi-message "Initializing completion ({func}compinit{rst}){…}"
          builtin autoload -Uz compinit
          compinit -d ${ZI[ZCOMPDUMP_PATH]:-${XDG_DATA_HOME:-$ZDOTDIR:-$HOME}/.zcompdump} "${(Q@)${(z@)ZI[COMPINIT_OPTS]}}"
        fi
        ;;
      (csearch)
        .zi-search-completions
        ;;
      (compinit)
        (( ${+functions[.zi-forget-completion]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
        .zi-compinit; ___retval=$?
        ;;
      (dreport)
        .zi-show-debug-report
        ;;
      (dclear)
        (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
        .zi-clear-debug-report
        ;;
      (dunload)
        (( ${+functions[.zi-service]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/additional.zsh"
        .zi-debug-unload
        ;;
      (compile)
        (( ${+functions[.zi-compile-plugin]} )) || builtin source "${ZI[BIN_DIR]}/lib/zsh/install.zsh" || return 1
        if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then
          [[ -z $2 ]] && { builtin print -r -- "Assuming --all is passed"; sleep 3; }
          .zi-compile-uncompile-all 1; ___retval=$?
        else
          .zi-compile-plugin "${2%%(///|//|/)}" "${3%%(///|//|/)}"; ___retval=$?
        fi
        ;;
      (uncompile)
        if [[ $2 = --all || ( -z $2 && -z $3 ) ]]; then
          [[ -z $2 ]] && { builtin print -r -- "Assuming --all is passed"; sleep 3; }
          .zi-compile-uncompile-all 0; ___retval=$?
        else
          .zi-uncompile-plugin "${2%%(///|//|/)}" "${3%%(///|//|/)}"; ___retval=$?
        fi
        ;;
      (compiled)
        .zi-compiled
        ;;
      (cdlist)
        .zi-list-compdef-replay
        ;;
      (cd|delete|recall|edit|glance|changes|create|stress)
        .zi-"$1" "${@[2-correct,-1]%%(///|//|/)}"; ___retval=$?
        ;;
      (recently)
        shift
        .zi-recently "$@"; ___retval=$?
        ;;
      (control)
        .zi-control-menu
        ;;
      (analytics)
        .zi-analytics-menu
        ;;
      (-h|--help|help)
        .zi-help
        ;;
      (ls)
        shift
        .zi-ls "$@"
        ;;
      (srv)
        () { setopt localoptions extendedglob warncreateglobal
        [[ ! -e ${ZI[SERVICES_DIR]}/"$2".fifo ]] && { builtin print "No such service: $2"; } ||
          { [[ $3 = (#i)(next|stop|quit|restart) ]] &&
            { builtin print "${(U)3}" >>| ${ZI[SERVICES_DIR]}/"$2".fifo || builtin print "Service $2 inactive"; ___retval=1; } ||
              { [[ $3 = (#i)start ]] && rm -f ${ZI[SERVICES_DIR]}/"$2".stop ||
                { builtin print "Unknown service-command: $3"; ___retval=1; }
              }
          }
        } "$@"
        ;;
      (module)
        .zi-module "${@[2-correct,-1]}"; ___retval=$?
        ;;
      (*)
        if [[ -z $1 ]] {
          +zi-message -n "{b}{u-warn}ERROR{b-warn}:{rst} Missing a {cmd}subcommand "
          +zi-prehelp-usage-message rst
        } else {
          +zi-message -n "{b}{u-warn}ERROR{b-warn}:{rst} Unknown subcommand{ehi}:{rst}" "{apo}\`{error}$1{apo}\`{rst} "
          +zi-prehelp-usage-message rst
        }
        ___retval=1
        ;;
    esac
    ;;
esac

return ___retval
